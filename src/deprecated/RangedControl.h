#ifndef GLV_RANGEDCONTROL_H_INC
#define GLV_RANGEDCONTROL_H_INC

#include <vector>
#include "glv-core.h"

namespace glv {

class RangedValue;


/*
class View{
	void onAction();	// called by Window::findTarget()
}
*/
/*
A widget is able to be hook into a wide array of observable data.
Widgets are capable of both viewing and modifying data in some memory location
outside of its scope. This can be data generated by another process or data
stored in another object.  This external data is generally referred to as the
'model'.

It is also necessary for certain widgets to perform some action, like opening
a dialog box, when it is told to.

Customized behavior needs to be defined somewhere in the user's code.  It would
be advantageous if this behavior could be defined outside of the GLV base
classes, so that they are more resusable.  Right now, we require the user to
subclass Application and Window.  Model specific behavior is defined in
MyApplication and GUI specific behavior is defined in MyWindow.  For instance,
if you want a slider to move a view horizontally, you need to define this
behavior in MyWindow.  If you want a button to close the window

(1)	Widget	->	Modify/view data in some arbitrary object
(2)	Widget	->	Call method in some arbitrary object
(3)	Widget	->	Modify/view data at some memory location
(4)	Widget	->	Call C function or static method

Slider	->	Modify/view application data	(1)
Slider	->	Scroll view						(2)

Button	->	Modify/view application data	(1)
Button	->	Change visibility of a view		(1)
Button	->	Quit application				(2)

template <class T>
class Widget{
public:

	Widget(int l, int t, int w, int h, int numModels);

	bool connect(T * ref, int index = 0);

	bool connect(float * ref, int index = 0);
	bool connect(int * ref, int index = 0);
	bool connect(RangedValue * ref, int index = 0);

	float	getValueFloat();
	int		getValueInt();

	void (T :: * action)();		// member function in T

protected:
	std::vector<T *> mSlots;
	void * value;
	int valueType;
}

*/

///< Abstract class for any ranged value controller like a slider, knob, or dial.
class RangedControl : public View, public SignalFloat
{
public:
	RangedControl(int l, int t, int w, int h, int numParameters);
	virtual ~RangedControl(){}
	
	virtual void onDrag(Mouse * m){}
	virtual void onMouseDown(Mouse * m) = 0;
	
	bool connect(RangedValue *, int index = 0);	///< Connect model to controller's value vector.
												///< Returns true on success.
												
	float value(int index = 0);
	
	virtual void	onValue(float f) {	mValue = f; }

protected:
	std::vector<RangedValue *> mRangedValues;	// pointers to ranged values in the model
	
	float		mValue;
};


class Button : public RangedControl
{
public:
	Button(int l, int t, int w, int h);
	virtual ~Button();
	
	Color * activeColor;
	Color * iconColor;
	bool isToggleable;

	float iconScale;
	
	/// Icon drawing methods.  See class Icon for commonly used icons.
	/// Set button's inactive/active icon.
	void icon(void (* iconFunction)(float l, float t, float w, float h));

	/// Set button's inactive icon.
	void iconInactive(void (* iconFunction)(float l, float t, float w, float h));
	
	/// Set button's active icon.
	void iconActive(void (* iconFunction)(float l, float t, float w, float h));	
	
	virtual void onDraw();
	virtual void onMouseDown(Mouse * m);
	virtual void onMouseUp(Mouse * m);
	
protected:
	void (* mIconInactive)(float l, float t, float w, float h);
	void (* mIconActive)(float l, float t, float w, float h);	

};


class Slider : public RangedControl
{
public:
	Slider(int l=0, int t=0, int w=10, int h=100, bool setOnMouseDown=true);
	virtual ~Slider();
	
	Color * sliderColor;
	
	virtual void onDraw();
	virtual void onMouseDown(Mouse * m);
	virtual void onMouseUp(Mouse * m);
	virtual void onDrag(Mouse * m);
	virtual void onKeyDown(Keyboard * k);
	virtual void onKeyUp(Keyboard * k);
	
	void		setSensitivity(float f) { dragSensitivity = f; }
	
	bool		setOnMouseDown; ///< whether to jump to the current mouse position on clicked
	
protected:

	float		clickValue;		///< mvalue when the mouse clicked down on this control
	float		dragSensitivity;///< what to scale the mouse by when dragging (less than 1 for more sensitivity)
};


class Slider2d : public RangedControl
{
public:
	Slider2d(int l, int t, int w, int h);
	virtual ~Slider2d();
	
	Color * sliderColor;
	
	virtual void onDraw();
	
	virtual void onDrag(Mouse * m);
	virtual void onMouseDown(Mouse * m){}
};

class ScrollBar : public RangedControl
{
public:
	ScrollBar(int l=0, int t=0, int w=10, int h=100);
	virtual ~ScrollBar();

	virtual void onDraw();
	virtual void onMouseDown(Mouse * m);
	virtual void onMouseUp(Mouse * m);
	virtual void onDrag(Mouse * m);

	void setKnobScale(float scale);
	void setArrowButtonIncrement(float increment) { arrowButtonIncrement = increment; }
	bool isDragging() { return dragging; }

protected:
	
	Button *buttonUp, *buttonDown;

	bool dragging;
	float		clickValue;		///< mvalue when the mouse clicked down on this control
	float		kL, kT, kW, kH; // knob dimensions
	float		knobSize, trackSize, trackOffset;
	float		arrowButtonIncrement;
};

} // end namespace glv


#endif