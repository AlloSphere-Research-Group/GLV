GLV Design Notes
--------------------------------------------------------------------------------

Standard Widgets
----------------

Categories: Text, Valuator, Layout

Button
	state matches mouse button state
	action performed on button up only if in widget region

Checkbox
	state toggles on button down
	action performed on mouse down

Radio Button
	multiple buttons with only one on at a time
	value is an index of currently selected button

Slider
	draggable "tick" indicating value

Dial

Progress Bar
	display a "percent complete" as bar and optional text

Scroll Bar

Label

Text Edit
	edit a block of text

Line Edit
	edit a single line of text

Dropdown List
	box with popup list of strings
	value is an index of currently selected item

Menu
	grid that can be filled with any available widgets
	typically items are labels
	can nest menus

Group
	an invisible container of widgets
	can enforce a specific layout on children
	can tightly wrap itself around children

Pane
	a "window" with standard decorations, header/footer bars, close button, etc.

Tabbed Pane

Table
	display widgets on grid
	can draw lines at cell divisions
	can allow adjustment of cells by dragging on lines

Scroll
	allows contents to be scrolled via scrollbars


Standard View Events
--------------------
MouseDown, MouseUp, MouseDrag
KeyDown, KeyUp
Enter, Leave
Focus, Unfocus
Activate, Deactivate


View Properties
---------------
We should consider making all the bools in View part of a bit field.
This will result in better data alignment and smaller memory footprint. We can
use a 32-bit integer to leave plenty of room for future additions. There will
be one additional bit operation introduced for getting, setting, and toggling 
flags. We can have special setter and getter methods for the most used 
properties, such as visibility.

	// View properties
	enum{
		Visible			=1<<0,
		DrawBack		=1<<1,
		DrawBorder		=1<<2,
		CropChildren	=1<<3,
		FocusHighlight	=1<<4,
		HitTest			=1<<5
	};

	// Property methods (like OpenGL)
	int	     get(int prop){	return mFlags & prop; }
	void  enable(int prop){	mFlags |= prop; }
	void disable(int prop){	mFlags &= ~prop; }
	void  toggle(int prop){ mFlags ^= prop; }
	
	// Example usage
	view.enable(Visible | CropChildren);

	if(view.get(Visible)){
		// do something
	}


View Cropping
-------------

There are two different cropping behaviors for a view- cropping its children
and cropping its own drawing routine(s). Most of the time we will want everything
cropped, however, there are situations where this is not wanted. For instance, 
there may be label children attached outside the view's bounds that we do not
want to crop.

Who should determine if a view gets cropped, the parent or the child? Is the
flag 'cropChildren' or 'croppable'?



View Anchoring
--------------

We would like to make it easy to attach overlays onto views, such as labels
on sliders. Using a place enumeration may be too rigid to accomplish this.
Instead a view could have have scalars determining how much it translates
when its parent view is resized.



Layout
------
What is the exact function of a layout class?
	A rect generator? 
	A proxy to a parent view?
	
What view members are part of the layout besides its geometry?
	The anchor place?
		
If a layout object is a proxy, then we can avoid an extra step of adding the
view to its parent. 

	LayoutGrid(T pad, T numH, T numV, View& parentView);
	
Example code:
	// Horizontal slider bank with labels
	
	LayoutH lh();
	Slider sliders[n];
	for(n){
		const char c[2] = {i + '0', 0};
		lh  << (sliders[i] << new Label(c));
	}


Enumerations
------------
There are several methods for implementing enumerated types. The problem with the
standard/simple way, enum{ Left, Right, Up, Down }, is that the types lie in a 
flat namespace. The C-style way to organize types is to prepend them with a
category, i.e., enum{ KeyLeft, KeyRight, KeyUp, KeyDown}. This works, but it's
hard to maintain, especially when one wants to change the category name. 
A better method is to define enums in a C++ namespace like this:

	namespace Key{
		enum{ Left, Right, Up, Down };
	}
	
The constants can now be addressed as Key::Left, Key::Right, etc. One can also use
the "using namespace" directive to avoid having to type the category. Also,
we can add static methods to the namespace to operate on the types. For
instance, we can create a function to return a string based on the type.

	namespace Key{
		const char * getString(int type){
			switch(type){
			case Left:	return "Left";
			case Right:	return "Right";
			case Up:	return "Up";
			case Down:	return "Down";
			}
		}
	}

Another consideration is whether enumerations should be typed. Untyped enums
are more flexible since they are treated simply as int's. One scenario where
this is useful is when constants are locations in a bit field. The disadvantage
with untyped enums is that they are not type-safe.



Widget Value Model
------------------

Widgets which store values, such as buttons and sliders, have a base class
templated on their value type. The value type can be a dynamically sizable array,
Array, or a fixed-sized array, Values. The widget base classes can gracefully 
handle one or many values, so there is no need to write single-value and
many-valued versions for each widget. For instance, several types of fixed
sized Buttons can be created with a Values type:

	ButtonBase<Values<bool> >      b11;	// standard single
	ButtonBase<Values<bool>, 4>    b41;	// horizontal-array
	ButtonBase<Values<bool>, 1, 4> b14;	// vertical-array
	ButtonBase<Values<bool>, 4, 4> b44;	// matrix
	
For the dynamically-sized Array type, the x and y dimensions are passed into 
the constructor:
	
	ButtonBase<Array<bool> > button(Rect(100), 4, 4);

If dimensions are passed in when fixed-sized values are used, they are simply
ignored.

For convenience, the following typedefs are defined:

	typedef ButtonBase<Values<bool> > Button;
	typedef ButtonBase<Array<bool> >  Buttons;
	
	
	
Another concern about valued widgets is if/how they should handle various 
boundary conditions (clip, wrap), mapping strategies (log, pow), step amount, 
and range symmetry (e.g. [0,1] vs. [-1,1]).
Most widgets have very similar underlying algorithms with the main differences
being value type, presentation, and control.

				Value Model				Control			Presentation

	Widget		Range	Bound	Step	Click	Drag
	---------	---------------------	--------------	
	Button		[0,1]	wrap	1		toggle	none	symbol (on/off)
	Slider		[0,1]	clip	any		set		inc		rect
	Dial		[0,1]	wrap	any		set		inc		circle
	NumberBox	[a,b]	any		any		none	none	text


For the control and presentation of widgets, we could use a strategy pattern to
change behaviors at run-time. For presentation, we could have a list of strategies.
This would be useful for sliders to display both the bar and its value.



Notifications
-------------


Data
--------------------------------------------------------------------------------

Should we distinguish between compact and extended dimensions?
	d < 0 are compact (color, orientation)
	d >=0 are extended (spatial position, time)





Model
--------------------------------------------------------------------------------

There are three distinct types of models:
- data, parameters and state associated with a simulation or recording
- view, variables determining presentational aspects of views
- layout, geometry and spatial relationships of views


Data Model:

slider = 0.5
sliders = { 0.1, 0.4, 1, 0 }


View Model:

gridView = {
	major = 1,
	minor = 4,
	showAxes = 1,
	showGrid = 1,
	interval = {-1, 1, -1, 1},
}

view3D = {
	near = 0.1,
	far = 100,
	fovy = 60
}


class Model{
	virtual string modelToToken() = 0;
	virtual int modelFromString() = 0;
};

class DataModel{
	virtual string modelToToken(){
		return data.toToken();
	}
	
	virtual int modelFromString(string s){
		data.fromToken(s);
	}
	
	Data data;
};

class ViewModel{
	
};


class View{
	Model * mDataModel;
	Model * mViewModel;
};



OpenGL Compatibility
--------------------------------------------------------------------------------
It's possible to support both ES1 and ES2 in the same app, but two entirely 
independent rendering code paths are required. To switch renderers at run-time
we would need to make a draw::renderer(GLV_ES1 / GLV_ES2) call.

Some GL calls are supported by both ES1 and ES2, but in general, ES1 cannot use 
shaders while ES2 must use them (ugh!). Here is a brief compatibility list:

						ES 1.1		ES 2
Clear					x			x
ClearColor				x			x
Viewport				x			x
DrawArrays				x			x
GL_COLOR_BUFFER_BIT		x			x

PushMatrix				x
PopMatrix				x
MatrixMode				x
Frustum					x
Ortho					x
EnableClientState		x

UseProgram							x
EnableVertexAttribArray				x
VertexAttribPointer					x
GetAttribLocation					x
GetUniformLocation					x
UniformMatrix4fv					x


GLV could have two renderers: FIXED and PROG

FIXED would support both ES1 and OGL1.5
PROG  would support both ES2 and OGL2.0

Pseudo-code:
	/*
		GLV_PIPE_MODE is one of

			GLV_FIX_PIPE, GLV_PRG_PIPE, GLV_DUO_PIPE

		and will be known at compile time.
	*/

	template<int PIPE>
	struct Renderer{

		enum Mode{ FIXED, PROGRAMMABLE };

		// Setup on context initialization (load main shaders, textures, etc.)
		void contextCreate();

		// Clean-up on context destruction
		void contextDestroy();

		// Set rendering mode (GLV_DUO_PIPE only!)
		void mode(Mode v);
	};


	// Singleton renderer
	Renderer<GLV_PIPE_MODE> renderer;




Shader setup code (courtesy of Apple, Inc.):

GLuint RenderingEngine2::BuildShader(const char* source, GLenum shaderType) const
{
    GLuint shaderHandle = glCreateShader(shaderType);
    glShaderSource(shaderHandle, 1, &source, 0);
    glCompileShader(shaderHandle);
    
    GLint compileSuccess;
    glGetShaderiv(shaderHandle, GL_COMPILE_STATUS, &compileSuccess);
    
    if (compileSuccess == GL_FALSE) {
        GLchar messages[256];
        glGetShaderInfoLog(shaderHandle, sizeof(messages), 0, &messages[0]);
        std::cout << messages;
        exit(1);
    }
    
    return shaderHandle;
}

GLuint RenderingEngine2::BuildProgram(const char* vertexShaderSource,
                                      const char* fragmentShaderSource) const
{
    GLuint vertexShader = BuildShader(vertexShaderSource, GL_VERTEX_SHADER);
    GLuint fragmentShader = BuildShader(fragmentShaderSource, GL_FRAGMENT_SHADER);
    
    GLuint programHandle = glCreateProgram();
    glAttachShader(programHandle, vertexShader);
    glAttachShader(programHandle, fragmentShader);
    glLinkProgram(programHandle);
    
    GLint linkSuccess;
    glGetProgramiv(programHandle, GL_LINK_STATUS, &linkSuccess);
    if (linkSuccess == GL_FALSE) {
        GLchar messages[256];
        glGetProgramInfoLog(programHandle, sizeof(messages), 0, &messages[0]);
        std::cout << messages;
        exit(1);
    }
    
    return programHandle;
}


Vertex shader:
	varying lowp vec4 DestinationColor;
	void main(){
		gl_FragColor = DestinationColor;
	}

Fragment shader:
	attribute vec4 Position;
	attribute vec4 SourceColor;
	varying vec4 DestinationColor;
	uniform mat4 Projection;
	uniform mat4 Modelview;

	void main(){
		DestinationColor = SourceColor;
		gl_Position = Projection * Modelview * Position;
	}

